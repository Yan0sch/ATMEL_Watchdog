id: Nl9g683l6DXIWi82
createdBy: QfDgkCisYKoZ
dateCreated: 1750351126309
name: Meine neue Klasse
meta:
  logo: ''
  description: ''
  selfAssign: true
  defaultNumberOfRooms: '0'
members:
  teacher: []
  student: []
modules:
  - url: https://edrys-labs.github.io/module-markdown-it/index.html
    config:
      content: >
        # Der WatchDog Timer


        Der Watchdog-Timer ist eine in den Mikrocontroller integrierte
        Sicherheitsfunktion, die ursprünglich dafür gedacht ist, Systeme bei
        Software-Fehlern oder Hängern automatisch zurückzusetzen. Doch er kann
        mehr: In stromsparenden Anwendungen lässt sich der WDT auch als
        regelmäßiger Wecktimer nutzen – ganz ohne externe Komponenten.


        In dieser Übung lernst du:


        - wie der WDT auf dem ATmega328P (z. B. Arduino Uno) konfiguriert wird,

        - wie der WDT Hänger vermeiden kann

        - wie du damit den Mikrocontroller aus dem tiefsten Sleep-Modus
        („Power-down“) weckst
    studentConfig:
      content: ''
    teacherConfig:
      content: ''
    stationConfig:
      content: ''
    showInCustom: Lobby
    width: full
    height: tall
  - url: https://edrys-labs.github.io/module-markdown-it/index.html
    config:
      content: >-
        # Aufgabe 1

        ## Einführung

        1. Beschäftige dich mit dem Watchdog Timer des ATMega32. Schaue dafür in
        das Datenblatt.

        2. Was sind die Unterschiede bzw. Besonderheiten im Gegensatz zum
        klassischen Timer? Welche Features hat der Watchdog Timer und welche
        nicht?

        3. Wie kann der Watchdog Timer genutzt werden? Welche Register werden
        dazu benötigt?  Gibt es Besonderheiten beim Schreiben der Register?


        ## Hello World! aber mit Wachhund

        1. Die LED an `Pin 13` (`PB5`) soll zum blinken gebracht werden.

        Schaue dir dafür den Code im Editor an.

        2. Fülle die Fehlenden Stellen (`TODO`) aus.
            - Wie muss der Watchdog Timer mittels WDTCSR konfiguriert damit ein Interrupt aber kein Reset ausgelöst wird?
            - Stelle den Prescaler so ein, dass der WDT bei 500 ms überläuft.
            - Wie wird die LED in der Interrupt Subroutine geschalten?

        ### Initialer Code

        ```cpp

        #include <avr/io.h>

        #include <avr/interrupt.h>

        #include <util/delay.h>


        #define LED PB5

        ISR(WDT_vect){
            // TODO
        }

        int main() {
            // Pin 13 as output
            DDRB |= 1 << LED;
            
            // Deactivate external reset
            DDRD |= 1 << PD2;
            PORTD |= 0 << PD2;

            // set the change enable bit
            WDTCSR |= 1 << WDCE | 1 << WDE;

            // setup the watchdog timer
            WDTCSR = 0 // TODO

            sei();
            
            while(1);
        }

        ```
    studentConfig:
      content: ''
    teacherConfig:
      content: ''
    stationConfig:
      content: ''
    showInCustom: station
    width: half
    height: tall
  - url: https://edrys-labs.github.io/module-markdown-it/index.html
    config:
      content: >-
        # Aufgabe 2

        ## Anwendung des Watchdog Timers

        1. Schaue dir die Reset Mechanismen im Datenblatt an. Wie kann man
        auslesen, was den Reset ausgelöst hat?

        2. Schaue dir das Programm im Editor an und starte es. Was passiert
        dabei?

        3. Ändere `PORTD |= 0 << PD2;` zu `PORTD |= 1 << PD2;`. Das Aktiviert
        den zweiten Arduino, sodass der alle 10s einen externen Reset auslöst.
          - Woran kann man erkennen, dass der ATMEGA resettet wird?
          - An welcher Stelle im ATMEGA könnte man auslesen, welcher Reset ausgelöst wurde?
        4. Passe das Programm jetzt so an, dass sich der ATMEGA vorher mit dem
        Watchdog Timer selbst resettet.
          - mit den Registern aus dem Datenblatt
          - Nutze die `avr/wdt.h` Bibliothek. Eine kurze Doku dafür findest z.B. unter [avr-libc: <avr/wdt.h>: WatchDog timer handling](https://www.nongnu.org/avr-libc/user-manual/group__avr__watchdog.html).
        5. Wie kann man den WatchDog Timer resetten, bevor er den ATMEGA
        resettet?


        ### Initaler Code


        ```cpp

        #include <avr/io.h>

        #include <avr/interrupt.h>

        #include <avr/wdt.h>

        #include <util/delay.h>

        #include <Arduino.h>


        #define LED PB5


        void setup(){
            Serial.begin(9600);
            delay(200);
            
            // Pin 13 as output
            DDRB |= 1 << LED;

            // activate external reset
            DDRD |= 1 << PD2;
            PORTD |= 1 << PD2;

            // TODO
        }


        void loop(){
            for (int i = 0;;i++) {
                PORTB ^= 1 << LED;
                Serial.print("Iterationen: ");
                Serial.println(i);
                _delay_ms(500);
            }
        }

        ```
    studentConfig:
      content: ''
    teacherConfig:
      content: ''
    stationConfig:
      content: ''
    showInCustom: station
    width: half
    height: tall
  - url: https://edrys-labs.github.io/module-markdown-it/index.html
    config:
      content: >-
        # Aufgabe 3


        1. Im dritten Aufgabenkomplex simuliert der zweite Arduino einen Sensor.
        Die Daten werden über I²C übermittelt. Der Sensor ist allerdings
        unzuverlässig und sendet manchmal keine Daten. In diesem Fall muss per
        I²C einfach neu angefragt werden. Da der Arduino aber auf den Empfang
        von Daten wartet kann das Programm an der Stelle nicht weiterlaufen.

        2. Schaue dir das Programm unten an. Nutz den WatchDog Timer um hier
        Abhilfe zu schaffen. **Beachte:** Der Sensorwert soll weiterhin nur jede
        Sekunde abgefragt werden.


        An der Stelle ist zu erwähnen, dass dieser Fehler nur simuliert wird.
        Der Slave sendet mit einer Wahrscheinlichkeit von 70 % nichts, worauf
        der Master eine 0 empfängt. Sobalt der Master eine 0 empfängt geht der
        einfach in eine Endlosschleife.


        ```cpp

        #include <Wire.h>

        #include <Arduino.h>

        #include <avr/io.h>

        #include <avr/interrupt.h>

        #include <util/delay.h>

        #include <avr/wdt.h>


        uint8_t requestData();


        void setup() {
            Wire.begin(); // i2c as master
            Serial.begin(9600);
            delay(200);

            // Deactivate external reset
            DDRD |= 1 << PD2;
            PORTD |= 0 << PD2;
            
            // TODO
        }


        void loop() {
            Serial.print("Random Sensor Value ");
            int data = requestData();
            
            // TODO
            
            Serial.println(data);

            delay(1000);
        }


        uint8_t requestData(){
            // request data
            Wire.requestFrom(0x08, 1); // 1 Byte anfordern
            
            uint8_t response = 0;
            if(Wire.available()){
                response = Wire.read();
            } 
          
            // Check for Error
            while(!response);

            return response;
        }

        ```
    studentConfig:
      content: ''
    teacherConfig:
      content: ''
    stationConfig:
      content: ''
    showInCustom: station
    width: half
    height: tall
  - url: https://edrys-labs.github.io/module-markdown-it/index.html
    config:
      content: >-
        # Aufgabe 4

        ## WatchDog als Wecker


        Der Arduino soll alle 8s ein Statusupdate an den Seriellen Bus senden.
        In der Zeit dazwischen soll der ATMEGA aber nicht unnötig Strom
        verbrauchen und wird deshalb in den Sleep-Modus versetzt. Um den ATMEGA
        aufzuwecken soll der WatchDog Timer verwendet werden. Da kommt die
        `<avr/wdt.h>` auch an ihre Grenzen und der WatchDog Timer muss über die
        Register konfiguriert werden. Es ist also Arbeit mit dem Datenblatt
        angesagt.


        **Hinweis:** Schaue dir nochmal Aufgabe 1 an.


        ```cpp

        #include <Arduino.h>

        #include <avr/sleep.h>

        #include <avr/wdt.h>

        #include <avr/interrupt.h>


        volatile bool watchdog_triggered = false;


        ISR(WDT_vect) {
          watchdog_triggered = true; // check that the WDT was triggered
        }


        void setup() {
            Serial.begin(9600);
            delay(200);

            // deactivate external reset
            DDRD |= 1 << PD2;
            PORTD |= 0 << PD2;

            // TODO

            set_sleep_mode(SLEEP_MODE_PWR_DOWN);
            sleep_enable();
        }


        void loop() {
            if (watchdog_triggered) {
                watchdog_triggered = false;
                Serial.println("WatchDog Triggered! Send very important data ...");
                _delay_ms(100);
            }
            
            // go to sleep
            noInterrupts();
            sleep_bod_disable();
            interrupts();
            sleep_cpu();      

            // Program starts here after wake up
        }

        ```
    studentConfig:
      content: ''
    teacherConfig:
      content: ''
    stationConfig:
      content: ''
    showInCustom: station
    width: half
    height: tall
  - url: https://edrys-labs.github.io/module-monaco-editor/index.html
    config: ''
    studentConfig: ''
    teacherConfig: ''
    stationConfig: ''
    showInCustom: station
    width: full
    height: tall
  - url: https://edrys-labs.github.io/module-streaming/index.html
    config: ''
    studentConfig: ''
    teacherConfig: ''
    stationConfig: ''
    showInCustom: station
    width: third
    height: short
  - url: https://edrys-labs.github.io/module-pyxtermjs/index.html
    config: ''
    studentConfig: ''
    teacherConfig: ''
    stationConfig:
      server: ''
      execute: execute
      script: |-
        echo $CODE | base64 --decode > Hello.ino
        arduino-cli sketch new Hello
        olddir=$(pwd)
        mv Hello.ino Hello
        cd Hello
        arduino-cli board attach -p /dev/ttyACM0 -b arduino:avr:uno
        cd $olddir
        arduino-cli compile Hello && arduino-cli upload -p /dev/ttyACM0 Hello
        cat /dev/ttyACM0
      enable:
        student: false
        teacher: false
    showInCustom: station
    width: third
    height: medium
